from __future__ import annotations

from typing import TYPE_CHECKING, Any, Generator

from chess import PieceType

from PyAgrippa.Evaluation.BoardEvaluator import BoardEvaluator
from PyAgrippa.GUI.GUILayout import IGUILayout
from PyAgrippa.Moves.MoveRepresentation import IMoveRepresentation

if TYPE_CHECKING:
    from PyAgrippa.Boards.Board import IBoard
    from PyAgrippa.Squares.Square import ISquare


class IPiece:
    def __init__(self, isWhite: bool):
        self.board = None
        self.white = isWhite

    def getPythonChessPieceType(self) -> PieceType:
        raise NotImplementedError

    def __str__(self):
        return f"{'White' if self.isWhite() else 'Black'} {str(self.__class__.__name__)}"

    def __eq__(self, other: IPiece):
        if isinstance(other, IPiece):
            return self.getIdentifier() == other.getIdentifier()
        else:
            return False

    def isWhite(self):
        return self.white

    def isBlack(self):
        return not self.isWhite()

    def getImage(self, layout: IGUILayout):
        raise NotImplementedError

    def getBoard(self) -> IBoard:
        raise NotImplementedError

    def getSquare(self):
        return self.getBoard().getSquareOf(self)

    def getIdentifier(self) -> Any:
        """
        An identifier to communicate about pieces in a more efficient way (most of the time an integer). If a piece does
        not have an identifier, this just returns the piece itself.
        """
        raise NotImplementedError

    def getAllPseudoLegalMoves(self, moveRepresentation: IMoveRepresentation) -> Generator[Any, None, None]:
        raise NotImplementedError

    def getAllPseudoLegalCaptures(self, moveRepresentation: IMoveRepresentation) -> Generator[Any, None, None]:
        raise NotImplementedError

    def getAllPseudoLegalNonCaptures(self, moveRepresentation: IMoveRepresentation) -> Generator[Any, None, None]:
        raise NotImplementedError

    def evaluate(self, evaluator: BoardEvaluator):
        raise NotImplementedError

    def evaluateAt(self, evaluator: BoardEvaluator, square: ISquare):
        raise NotImplementedError

    def isLegalMove(self, move: Any, representation: IMoveRepresentation):
        raise NotImplementedError

    def isPseudoLegalMove(self, move: Any, representation: IMoveRepresentation):
        """
        Assumes the moving piece is self and that this move was generated by a move generator (so things like capturing
        a piece of the same type is not possible).
        :param move:
        :param representation:
        :return:
        """
        raise NotImplementedError


